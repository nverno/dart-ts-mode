class A {
  int b() {
    int c = 5;
  }
}

import 'package:dektor/catalog.dart';

import 'package:dektor/catalog.dart';

import 'package:dektor/catalog.dart';

import 'package:dektor/catalog.dart';

class Point {
}

class Point {
}

class Point {
}

abstract class ColoredPoint extends Point {
}

class Dog implements ISpeak {
}

class Point {
  var x;
  var s = 'g';

  void bar() {
    x = 2;
  }
}

class Beyonce {
  void calculateAnswer(double wingSpan, int numberOfEngines,
                       double length, double grossTons) {
      //do the calculation here
  }
}

class Point {
  int x, y;
  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }

  Point.json() {
    this(0, 0);
  }
  Point.json(this.x, this.y);
}

class Point {
  double Foo() {
    new BufferedWriter();
  }
}

class JayZ {
  void Beyonce() {
    int blue_ivy_carter;
  }
}

enum HandSign {
   SCISSOR, PAPER, STONE
}

var x = 0;

@annotation
final y = 0;

final y = 1.0;
final double y1 = 1.0;
const z = "100";
const String z1 = "100";

final $y$ = 0;

typedef CreateCallback = void Function(String);
typedef void EndCallback(String endValue);
typedef Future<String> Handler(String method, Map<String, String> parameters);
typedef MyFunction<T> = T Function();
typedef DismissMethod = Future<void> Function(WidgetTester tester, Finder finder, {@required AxisDirection gestureDirection});

#! /usr/bin/env dshell

import 'package:dshell/dshell.dart';

List<String> animations = ['1', '2', '3', '4', 'Default'];
final String assetFile = "assets/myasset.flr";
class MyClass {
  
}

void callback(Future<void> Function(String?) handler) {
}

const my.MyType newMyType = my.MyType();

final my.MyType newMyType = my.MyType();

main() {
  final my.myType newMyType = ggg;
}

void _invoke(void callback()?, Zone? zone) {
}

// Interesting issue of conflict between dart grammar itself and actual value of elements?

String get(String hello) => 'A string $hello';
class MyClass {
  void set(String name, Object value) {}
}

String get myGetterName => 'A string hello';
class MyClass {
  void set myValue(String name, Object value) {}
}

class Tree {
  Set toSet() {
    Set set = Set();
    set._count = _count;
    set._root = _root;
    return set;
  }
}

class MyClass {
  void mySet(String name, Object value) {}
}

class LinkedHashMap {
  external factory LinkedHashMap();


  external factory LinkedHashMap.identity();
}
